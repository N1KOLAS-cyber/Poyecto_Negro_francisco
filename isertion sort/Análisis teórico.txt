
Mejor Caso (Best Case)
Este es el escenario mÃ¡s favorable para el algoritmo de ordenamiento por inserciÃ³n. Se da cuando la lista ya estÃ¡ ordenada en su totalidad. En este caso, el algoritmo solo realiza un recorrido lineal por los elementos sin necesidad de realizar desplazamientos adicionales.

Complejidad Temporal:
ğ‘‚(ğ‘›)

def insertion_sort(arr):
    for j in range(1, len(arr)):  # Se ejecuta (n - 1) veces
        key = arr[j]              # Se ejecuta (n - 1) veces
        i = j - 1                 # Se ejecuta (n - 1) veces
        while i >= 0 and arr[i] > key:  # En el mejor caso, esta condiciÃ³n nunca se cumple (0 veces)
            arr[i + 1] = arr[i]         # No se realizan desplazamientos
            i -= 1                      # No hay decrementos en i
        arr[i + 1] = key  # Se ejecuta (n - 1) veces
Dado que en este caso el bucle while nunca se ejecuta, el tiempo total se puede expresar como:

ğ‘‡(ğ‘›) = ğ‘â‚(ğ‘› âˆ’ 1) + ğ‘â‚‚(ğ‘› âˆ’ 1) + ğ‘â‚ƒ(ğ‘› âˆ’ 1) + ğ‘â‚‡(ğ‘› âˆ’ 1) = ğ‘‚(ğ‘›)


Peor Caso (Worst Case)
Este es el escenario mÃ¡s desfavorable para el algoritmo. Se produce cuando la lista estÃ¡ completamente ordenada en orden inverso. En esta situaciÃ³n, cada elemento debe ser desplazado hasta la primera posiciÃ³n, lo que genera el mayor nÃºmero posible de comparaciones y movimientos dentro del arreglo.

Complejidad Temporal:
ğ‘‚(ğ‘›Â²)

def insertion_sort(arr):
    for j in range(1, len(arr)):  # Se ejecuta (n - 1) veces
        key = arr[j]              # Se ejecuta (n - 1) veces
        i = j - 1                 # Se ejecuta (n - 1) veces
        while i >= 0 and arr[i] > key:  # Se ejecuta aproximadamente n * (n - 1) veces
            arr[i + 1] = arr[i]         # Se ejecuta n * (n - 1) veces
            i -= 1                      # Se ejecuta n * (n - 1) veces
        arr[i + 1] = key  # Se ejecuta (n - 1) veces
En este caso, el bucle while se ejecuta tantas veces como sea necesario para reordenar cada elemento, lo que produce un crecimiento cuadrÃ¡tico en el tiempo de ejecuciÃ³n.

ğ‘‡(ğ‘›) = ğ‘â‚(ğ‘› âˆ’ 1) + ğ‘â‚‚(ğ‘› âˆ’ 1) + ğ‘â‚ƒ(ğ‘› âˆ’ 1) + ğ‘â‚„,â‚…,â‚†(ğ‘›(ğ‘› âˆ’ 1)) + ğ‘â‚‡(ğ‘› âˆ’ 1)

Por lo tanto, el tiempo de ejecuciÃ³n en el peor caso es ğ‘‚(ğ‘›Â²).


Caso Promedio (Average Case)
Este representa la situaciÃ³n mÃ¡s comÃºn en la ejecuciÃ³n del algoritmo. Se asume que los elementos del arreglo estÃ¡n en un orden aleatorio. En este caso, la cantidad de comparaciones y desplazamientos sigue un crecimiento cuadrÃ¡tico en promedio.

Complejidad Temporal:
ğ‘‚(ğ‘›Â²)

def insertion_sort(arr):
    for j in range(1, len(arr)):  # Se ejecuta (n - 1) veces
        key = arr[j]              # Se ejecuta (n - 1) veces
        i = j - 1                 # Se ejecuta (n - 1) veces
        while i >= 0 and arr[i] > key:  # En promedio, se ejecuta n/2 veces
            arr[i + 1] = arr[i]         # En promedio, ocurre n/2 veces
            i -= 1
        arr[i + 1] = key  # Se ejecuta (n - 1) veces
En este caso, el nÃºmero medio de comparaciones y desplazamientos se encuentra entre los valores del mejor y el peor caso, lo que lleva a la siguiente expresiÃ³n matemÃ¡tica:

ğ‘‡(ğ‘›) = ğ‘â‚(ğ‘› âˆ’ 1) + ğ‘â‚‚(ğ‘› âˆ’ 1) + ğ‘â‚ƒ(ğ‘› âˆ’ 1) + ğ‘â‚„,â‚…,â‚†(ğ‘›Â²(ğ‘› âˆ’ 1)) + ğ‘â‚‡(ğ‘› âˆ’ 1)

Dado que el tÃ©rmino dominante es ğ‘›Â², la complejidad sigue siendo ğ‘‚(ğ‘›Â²).


